《C++PrimerPlus》读书笔记

### 函数模板
函数模板是通用的函数描述，使用泛型来定义函数，其中的泛型可用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。[function_template.cpp](./function_template.cpp)

**显式具体化:** 为特定类型提供具体化的模板定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。
- 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及他们的重载版本。
- 显式具体化的原型和定义应以`template<>`开头，并通过名称来指出类型。
- 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。

**关键字decltype（C++11）**         
有时我们希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量。为了满足这一需求，C++11新标准引入了`decltype`类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。
```c++
template<class T1, class T2>
void printplus(T1 a, T2 b) {
    decltype(a+b) c = a + b;        // 如果这里不用decltype，无法判断a+b的结果是T1类型还是T2类型或者其他类型
    cout << c;
}
```

### 友元friend
在C++中非类成员函数是不能直接访问私有成员及，私有成员函数的，但有时候我们又需要某些函数或者类可以打破这个限制，可以访问到，这就是C++友元机制。友元有三种：
- 友元函数
- 友元类
- 友元成员函数

代码示例[friend.cpp](./friend.cpp)