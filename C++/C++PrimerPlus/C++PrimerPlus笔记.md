《C++PrimerPlus》读书笔记

### 函数模板
函数模板是通用的函数描述，使用泛型来定义函数，其中的泛型可用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。[function_template.cpp](./function_template.cpp)

**显式具体化:** 为特定类型提供具体化的模板定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。
- 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及他们的重载版本。
- 显式具体化的原型和定义应以`template<>`开头，并通过名称来指出类型。
- 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。

**关键字decltype（C++11）**         
有时我们希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量。为了满足这一需求，C++11新标准引入了`decltype`类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。
```c++
template<class T1, class T2>
void printplus(T1 a, T2 b) {
    decltype(a+b) c = a + b;        // 如果这里不用decltype，无法判断a+b的结果是T1类型还是T2类型或者其他类型
    cout << c;
}
```

### 友元friend
在C++中非类成员函数是不能直接访问私有成员及，私有成员函数的，但有时候我们又需要某些函数或者类可以打破这个限制，可以访问到，这就是C++友元机制。友元有三种：
- 友元函数
- 友元类
- 友元成员函数

代码示例[friend.cpp](./friend.cpp)


### 异常机制
C++异常是对程序运行过程中发生的异常情况的一种响应，异常提供了将控制权从程序的一部分传递到另一部分的途径。在C++中，主要用`try-catch`捕获异常。

代码示例[abort.cpp](./abort.cpp)

C++11中新增了一个关键字`noexcept`指出函数不会引发异常：
```c++
double marm() noexcept;     //marm() doesn't throw an exception.
```
当使用这个关键字时，等于是程序员向编译器做出了承诺，放心吧，这个函数不会引发异常。


### 智能指针
比较早的智能指针是`auto_ptr`，但现在已经不推荐使用，现在推荐使用的智能指针是`unique_ptr`、`shared_ptr`、`weak_ptr`。那这三种智能指针该如何使用呢？

如果程序要使用多个指向同一个对象的指针，应选择`shared_ptr`。如果程序不需要多个指向同一个对象的指针，则可使用`unique_ptr`。`weak+ptr`较为特殊，一般与`shared_ptr`配合使用，它可以指向`shared_ptr`所指向的对象，但却不增加对象的引用计数，这样就有可能出现`weak_ptr`所指向的对象实际上已经被释放了的情况。

代码示例[cpp11.cpp](./cpp11.cpp)

### C++11
前面已经提到一些C++11的内容，这里再继续谈一些。当然，这里列出的不是全部，只选取了其中一部分。

1. 增加了新类型`long long`、`unsigned long long`、`char16_t`、`char32_t`。

2. 增加了空指针`nullptr`，推荐使用`nullptr`而不是0提供了更高类型的安全。

3. 新的基于范围的`for`循环。

4. 新增智能指针`unique_ptr`、`shared_ptr`、`weak_ptr`。

5. 右值引用`&&`，移动语义（move semantics）。

6. Lambda表达式。

7. 并行编程。


代码示例[cpp11.cpp](./cpp11.cpp)

### Boost
开源库，里面有很多库，比如常用的日志库、线程库等。

